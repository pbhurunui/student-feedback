<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Teaching Effectiveness Dashboard</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // GLOBAL FIREBASE SETUP (Mandatory for professional apps)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        if (firebaseConfig) {
            setLogLevel('Debug');
            const app = initializeApp(firebaseConfig);
            window.db = getFirestore(app);
            window.auth = getAuth(app);
            
            async function initializeAuth() {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(window.auth, initialAuthToken);
                    } else {
                        await signInAnonymously(window.auth);
                    }
                    console.log("Firebase Auth initialized successfully.");
                } catch (error) {
                    console.error("Firebase Auth error:", error);
                }
            }
            initializeAuth();
        } else {
            console.warn("Firebase configuration not available. Running in local mode.");
        }
    </script>
    
    <style>
        /* Custom styles for the blackboard look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a; /* Very dark charcoal/blackboard color */
        }
        .blackboard-bg {
            background-color: #224229; /* Deep green for the board surface */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            border-radius: 1rem;
            border: 10px solid #795548; /* Wood frame color */
        }
        .chalk-text {
            color: #fffbe6; /* Off-white, chalk color */
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.2);
        }
        .chalk-heading {
            border-bottom: 2px dashed #90a4ae; /* Light gray chalk line */
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }
        .score-box {
            background-color: rgba(255, 255, 255, 0.1); /* Slightly lighter chalk box */
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .btn-analyze {
            background-color: #fca311;
            color: #1a1a1a;
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn-analyze:hover {
            background-color: #e5930e;
            transform: translateY(-1px);
        }
        .drag-over {
            border-color: #fcd34d !important; /* Tailwind yellow-300 */
            background-color: rgba(252, 211, 77, 0.1) !important;
            box-shadow: 0 0 10px rgba(252, 211, 77, 0.5);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="dashboard" class="blackboard-bg max-w-6xl mx-auto p-6 md:p-10">

        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-extrabold chalk-text mb-2">Live Teaching Effectiveness Dashboard</h1>
            <p class="text-xl chalk-text font-light">Upload Student Feedback & Paste Observation Reports for Instant Analysis</p>
        </header>
        
        <!-- File Input Section -->
        <section id="upload-section" class="mb-10 p-6 score-box border-2 border-dashed border-gray-500 rounded-xl">
            <h2 class="text-2xl font-bold chalk-text mb-4 text-yellow-400">Data Input</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Student Feedback Files (CSV) with Drag and Drop -->
                <div>
                    <label class="block text-sm font-medium chalk-text mb-1 text-yellow-300">Student Feedback CSVs (Drag & Drop or Click)</label>
                    <!-- Hidden input to hold the file list -->
                    <input type="file" id="feedback-files" multiple accept=".csv" class="hidden" /> 
                    
                    <div id="drop-zone" class="border-2 border-dashed border-gray-400 rounded-lg p-6 text-center cursor-pointer transition duration-200 hover:border-yellow-300 hover:bg-gray-700/30">
                        <p id="drop-text" class="chalk-text text-lg">Drag & drop your **CSV files** here, or click to browse.</p>
                        <p id="file-count" class="text-sm text-green-300 mt-2 hidden">0 files selected.</p>
                    </div>
                    <p class="text-xs text-gray-400 mt-2">Note: For Google Drive files, please **download** them first, then drop here.</p>
                </div>

                <!-- Observation Text (Google Doc Paste) -->
                <div>
                    <label class="block text-sm font-medium chalk-text mb-1 text-pink-300">Observation Report(s) (Paste Google Doc Content)</label>
                    <textarea id="observation-text" rows="8" placeholder="Paste the full text of one or more observation reports here. Separate multiple reports with a blank line or '--- NEW OBSERVATION ---'." class="w-full p-3 rounded-lg bg-gray-700/50 text-gray-200 border border-gray-600 focus:ring-pink-500 focus:border-pink-500 placeholder-gray-500"></textarea>
                </div>
            </div>

            <button id="analyze-button" class="btn-analyze w-full py-3 rounded-xl text-xl font-bold shadow-lg flex items-center justify-center">
                <svg id="analyze-icon" class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                <svg id="loading-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-black" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" style="display: none;">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span id="analyze-text">Analyze Data & Update Dashboard</span>
            </button>
            <p id="analysis-status" class="text-center mt-3 text-sm font-medium text-red-300 hidden"></p>
        </section>


        <!-- Main Dashboard Content -->
        <div id="main-content" class="space-y-12">
            
            <!-- 1. Overall Student Feedback Comparison -->
            <section>
                <h2 class="text-3xl font-bold chalk-text chalk-heading">1. Student Feedback Trend Analysis (1-5 Scale)</h2>
                <div id="overall-scores" class="overflow-x-auto">
                    <p class="chalk-text p-4 text-center">Upload CSV files to begin analysis.</p>
                </div>
            </section>

            <!-- 2. Combined Subject-Specific Analysis (Student & Observation) -->
            <section>
                <h2 class="text-3xl font-bold chalk-text chalk-heading">2. Subject-Specific Deep Dive</h2>
                <div id="subject-trends" class="grid grid-cols-1 md:grid-cols-3 gap-6">
                     <p class="chalk-text p-4 md:col-span-3 text-center">Subject results will appear here after analysis.</p>
                </div>
            </section>
            
            <!-- 3. Qualitative Insights -->
            <section>
                <h2 class="text-3xl font-bold chalk-text chalk-heading">3. Qualitative & Observation Insights</h2>
                <div id="two-column-layout" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    
                    <!-- LEFT COLUMN: Qualitative Feedback -->
                    <div class="space-y-6">
                         <div class="score-box p-6 rounded-xl">
                            <h3 class="text-xl font-semibold chalk-text mb-4 text-yellow-300">üëç Top Positive Themes (from Feedback)</h3>
                            <ul id="positive-feedback-list" class="list-disc list-inside space-y-2 chalk-text ml-4">
                                <li class="text-lg text-gray-400">Awaiting qualitative analysis...</li>
                            </ul>
                        </div>
                        <div class="score-box p-6 rounded-xl">
                            <h3 class="text-xl font-semibold chalk-text mb-4 text-red-300">üí° Key Improvement Areas (from Feedback)</h3>
                            <ul id="improvement-feedback-list" class="list-disc list-inside space-y-2 chalk-text ml-4">
                                <li class="text-lg text-gray-400">Awaiting qualitative analysis...</li>
                            </ul>
                        </div>
                    </div>
                    
                    <!-- RIGHT COLUMN: Observation Data -->
                    <div class="score-box p-6 rounded-xl">
                        <h3 class="text-xl font-semibold chalk-text mb-4 text-pink-300">4. Professional Observation Metrics</h3>
                        <div id="observation-metrics">
                            <p class="chalk-text p-4 text-center">Paste observation text to see results.</p>
                        </div>
                    </div>

                </div>
            </section>

        </div>
    </div>

    <script>
        // =================================================================
        // IN-BROWSER JAVASCRIPT ANALYSIS ENGINE (with LLM Integration & DND)
        // =================================================================
        
        // --- 1. Scoring Mappings (Student Feedback) ---
        const CLARITY_INTEREST_MAP = {
            'Very Clear': 5, 'Very Interesting': 5,
            'Clear': 4, 'Interesting': 4,
            'Neutral': 3,
            'Okay': 2,
            'Not Clear': 1, 'Not Interesting': 1
        };

        const FREQUENCY_MAP = {
            'Always': 5, 'A Lot': 4, 'Often': 3, 'Sometimes': 2, 'A Little': 1, 'Never': 1
        };

        const SPEED_MAP = {
            'Very Quickly': 5, 'Quickly': 4, 'On Time': 3, 'Slowly': 2, 'Very Slowly': 1
        };

        const COMFORT_MAP = {
            'Very Comfortable': 5, 'Comfortable': 4, 'Not Comfortable': 1
        };
        
        // Hypothetical required columns for Student Feedback (must match your forms)
        const FEEDBACK_COL_MAP = {
            'How clearly do I explain the lessons?': 'Clarity_Score',
            'How interesting are the lessons?': 'Interest_Score',
            'Do I use different ways to explain things? e.g. videos/activities/examples': 'Methods_Score',
            'Do I encourage you to ask questions or participate in class?': 'Encourage_Score',
            'How much do you enjoy participating in class activities? e.g. pair work, group work, class discussions': 'Participate_Score',
            'Do I make learning engaging and enjoyable?': 'Engaging_Score',
            'Do I help you when you don‚Äôt understand something? ': 'Help_Score',
            'How comfortable do you feel asking for help in class?': 'Comfort_Score',
            'Do I create an environment where you feel safe and heard?': 'Safe_Score',
            'How quickly do I give feedback on work or assignments?': 'Feedback_Speed_Score',
            'What do I teach you?': 'Subject',
            'What do you like most about how I teach?': 'Qual_Positive',
            'What do you think could be improved about how I teach?': 'Qual_Improvement'
        };

        // --- 2. Shared Data Processing Utilities ---

        /** Simple CSV parsing function for in-browser use. */
        const csvToJson = (csvText, fileName) => {
            const lines = csvText.split(/\r?\n/).filter(line => line.trim() !== '');
            if (lines.length < 2) return [];

            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                // Simple regex to handle commas inside quoted fields (best effort)
                const values = lines[i].match(/(".*?"|[^",\s]+)(?=\s*,\s*|\s*$)/g) || [];
                if (values.length !== headers.length) continue;

                const obj = {};
                headers.forEach((header, index) => {
                    let value = values[index] ? values[index].trim().replace(/"/g, '') : '';
                    obj[header] = value;
                });
                // Source Term is usually derived from the filename of the form response
                obj['Source_Term'] = fileName.replace(".csv", "").split(" - ")[0].trim(); 
                data.push(obj);
            }
            return data;
        };

        const processFile = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const json = csvToJson(e.target.result, file.name);
                        resolve(json);
                    } catch (error) {
                        reject(`Error parsing ${file.name}: ${error.message}`);
                    }
                };
                reader.onerror = (e) => reject(`Error reading file ${file.name}`);
                reader.readAsText(file);
            });
        };
        
        const cleanSubject = (df) => {
             // Handle multi-topic responses and clean up the subject column
             df.forEach(row => {
                 let subject = row['Subject'] || 'Unspecified';
                 subject = subject.split(',')[0].trim();
                 if (subject.toLowerCase() === 'nan' || subject === '' || subject === '-') {
                     subject = 'Unspecified';
                 }
                 row['Subject'] = subject;
             });
             return df;
        };
        
        // --- 3. Student Feedback Analysis Logic ---
        const getTopWords = (texts, n = 5) => {
            const text = texts.join(' ').toLowerCase();
            const stopWords = new Set(['the', 'a', 'and', 'to', 'is', 'i', 'of', 'in', 'you', 'it', 'me', 'that', 'but', 'how', 'we', 'do', 'or', 'so', 'for', 'my', 'about', 'on', 'your', 'with', 'dont', 'not', 'no', 'what', 'like', 'be', 'can', 'get', 'was', 'very', 'always', 'much', 'just', 'we', 'our', 'could', 'would', 'them']);
            const words = text.split(/\s+/).map(word => word.replace(/[^a-z0-9]/g, '').trim()).filter(word => word.length > 2 && !stopWords.has(word));
            
            const wordCounts = {};
            words.forEach(word => {
                wordCounts[word] = (wordCounts[word] || 0) + 1;
            });
            
            const sortedWords = Object.entries(wordCounts).sort(([, countA], [, countB]) => countB - countA);
            return sortedWords.slice(0, n).map(([word]) => word.charAt(0).toUpperCase() + word.slice(1));
        };
        
        const analyzeStudentFeedback = (dataFrames) => {
            let combinedData = dataFrames.flat();
            if (combinedData.length === 0) return { overallMetrics: [], subjectAverages: {}, qualitative: { positive: [], improvement: [] } };

            combinedData = cleanSubject(combinedData);
            
            // Apply scoring
            const scoreCols = [];
            combinedData.forEach(row => {
                Object.keys(FEEDBACK_COL_MAP).forEach(originalKey => {
                    const newKey = FEEDBACK_COL_MAP[originalKey];
                    const value = row[originalKey] || '';
                    if (newKey.endsWith('_Score')) {
                        let score = 0;
                        if (newKey.includes('Clarity') || newKey.includes('Interest')) {
                            score = CLARITY_INTEREST_MAP[value] || 0;
                        } else if (newKey.includes('Speed')) {
                            score = SPEED_MAP[value] || 0;
                        } else if (newKey.includes('Comfort')) {
                            score = COMFORT_MAP[value] || 0;
                        } else { // Frequency-based
                            score = FREQUENCY_MAP[value] || 0;
                        }
                        row[newKey] = score;
                        if (!scoreCols.includes(newKey)) scoreCols.push(newKey);
                    } else if (newKey === 'Subject') {
                        row[newKey] = row[newKey] || 'Unspecified';
                    } else if (newKey.startsWith('Qual_')) {
                        row[newKey] = value;
                    }
                });
            });

            // Calculate Overall Average Score for each row
            combinedData.forEach(row => {
                const scores = scoreCols.map(col => row[col]).filter(s => s > 0);
                row['Overall_Avg_Score'] = scores.length ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
            });

            // Group by Source_Term for Overall Metrics
            const termAverages = {};
            combinedData.forEach(row => {
                const term = row['Source_Term'];
                termAverages[term] = termAverages[term] || { count: 0, totalScores: {} };
                termAverages[term].count++;
                scoreCols.concat(['Overall_Avg_Score']).forEach(col => {
                    termAverages[term].totalScores[col] = (termAverages[term].totalScores[col] || 0) + (row[col] || 0);
                });
            });

            const overallMetrics = [];
            const sortedTerms = Object.keys(termAverages).sort();
            const term_earliest_label = sortedTerms[0];
            const term_latest_label = sortedTerms[sortedTerms.length - 1];

            if (sortedTerms.length >= 1) {
                const term_earliest = termAverages[term_earliest_label];
                const term_latest = termAverages[term_latest_label];
                
                const metricMap = {
                    'Overall_Avg_Score': 'Teaching Effectiveness Index',
                    'Clarity_Score': 'Clarity of Lessons',
                    'Comfort_Score': 'Student Comfort (Asking for Help)',
                    'Engaging_Score': 'Engagement/Enjoyment',
                    'Feedback_Speed_Score': 'Feedback Speed'
                };

                Object.keys(metricMap).forEach(oldCol => {
                    const t1 = (term_earliest.totalScores[oldCol] || 0) / term_earliest.count;
                    const t3 = (term_latest.totalScores[oldCol] || 0) / term_latest.count;
                    overallMetrics.push({
                        metric: metricMap[oldCol],
                        t1: t1,
                        t3: t3,
                        t1_label: term_earliest_label,
                        t3_label: term_latest_label,
                        color: 'text-yellow-300'
                    });
                });
            }

            // Group by Subject for Subject Averages
            const subjectAverages = {};
            const subjectTerms = {};

            combinedData.forEach(row => {
                const key = `${row['Subject']}__${row['Source_Term']}`;
                subjectTerms[key] = subjectTerms[key] || { data: [], totalScores: {} };
                subjectTerms[key].data.push(row);
                
                scoreCols.concat(['Overall_Avg_Score']).forEach(col => {
                    subjectTerms[key].totalScores[col] = (subjectTerms[key].totalScores[col] || 0) + (row[col] || 0);
                });
            });

            Object.keys(subjectTerms).forEach(key => {
                const [subject, term] = key.split('__');
                const group = subjectTerms[key];
                const count = group.data.length;
                
                const avgScores = {};
                scoreCols.concat(['Overall_Avg_Score']).forEach(col => {
                    avgScores[col] = group.totalScores[col] / count;
                });
                
                const lowestScoreCol = scoreCols.reduce((minCol, col) => 
                    (avgScores[col] || 0) < (avgScores[minCol] || 0) ? col : minCol, scoreCols[0]
                );
                const lowestAreaName = lowestScoreCol.replace('_Score', '').replace('_', ' ').split('(')[0].trim().toUpperCase();

                subjectAverages[subject] = subjectAverages[subject] || { full_history: [] };
                subjectAverages[subject].full_history.push({
                    Source_Term: term,
                    Overall_Avg_Score: avgScores['Overall_Avg_Score'],
                    Lowest_Area: lowestAreaName
                });
                
                // Sort history and set latest values
                subjectAverages[subject].full_history.sort((a, b) => a.Source_Term.localeCompare(b.Source_Term));
                const latest = subjectAverages[subject].full_history[subjectAverages[subject].full_history.length - 1];
                subjectAverages[subject].latest_term = latest.Source_Term;
                subjectAverages[subject].latest_score = latest.Overall_Avg_Score;
                subjectAverages[subject].lowest_area = latest.Lowest_Area;
            });

            // Qualitative Analysis
            const positiveWords = getTopWords(combinedData.map(r => r.Qual_Positive).filter(Boolean), 5);
            const improvementWords = getTopWords(combinedData.map(r => r.Qual_Improvement).filter(Boolean), 5);

            return { overallMetrics, subjectAverages, qualitative: { positive: positiveWords, improvement: improvementWords } };
        };


        // --- 4. LLM API Call for Observation Data Extraction ---
        const API_MODEL = 'gemini-2.5-flash-preview-05-20';
        const API_KEY = "";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=${API_KEY}`;
        
        /**
         * Uses Gemini to extract structured observation data from unstructured text.
         * @param {string} rawText - The text content of the observation report(s).
         * @returns {Promise<Array<Object>>} - An array of structured observation objects.
         */
        const extractObservationDataWithGemini = async (rawText) => {
            const systemPrompt = `You are a data extraction specialist. Your task is to analyze raw lesson observation reports provided as unstructured text. Identify and extract the required structured metrics, which must be scores on a 1-5 scale, as well as the subject and term of the observation. 

            Instructions:
            1. Analyze the text for explicit scores (1-5) or infer them based on the qualitative tone (e.g., 'Excellent pacing' = 5, 'Needs improvement in engagement' = 2, 'Satisfactory' = 3).
            2. If you cannot find a subject or term, use 'Unspecified' for that field.
            3. The user may paste multiple observation reports, separated by a blank line, a series of dashes (---), or other separators. You must process all distinct reports and return an array of objects, one for each report.
            4. Only return the final JSON array. Do not add any conversational text or markdown formatting outside the JSON object.
            
            Metrics to Extract (1-5 Scale):
            - Pace: Lesson Pacing and Structure
            - Engagement: Student Participation and Focus
            - Management: Classroom Management and Discipline
            - Subject: The subject taught
            - Source_Term: The term or date of the observation (e.g., T3 2025 Observation)`;

            const payload = {
                contents: [{ parts: [{ text: rawText }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "Pace": { "type": "INTEGER" },
                                "Engagement": { "type": "INTEGER" },
                                "Management": { "type": "INTEGER" },
                                "Subject": { "type": "STRING" },
                                "Source_Term": { "type": "STRING" }
                            },
                            propertyOrdering: ["Pace", "Engagement", "Management", "Subject", "Source_Term"]
                        }
                    }
                }
            };
            
            const maxRetries = 3;
            let lastError = null;
            
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    const candidate = result.candidates?.[0];
                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const jsonString = candidate.content.parts[0].text;
                        // The model returns a stringified JSON array, so parse it.
                        try {
                            const parsedJson = JSON.parse(jsonString);
                            if (Array.isArray(parsedJson)) {
                                return parsedJson;
                            } else {
                                // Sometimes the model returns a single object instead of an array with one object
                                if (typeof parsedJson === 'object' && parsedJson !== null) {
                                    return [parsedJson];
                                }
                                throw new Error("LLM response did not return an array of observations.");
                            }
                        } catch (e) {
                            throw new Error(`Failed to parse LLM JSON output: ${e.message}`);
                        }
                    }
                    throw new Error("LLM returned an invalid candidate structure.");
                } catch (error) {
                    lastError = error;
                    if (attempt < maxRetries - 1) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw new Error(`Failed to extract data after ${maxRetries} attempts: ${lastError.message}`);
                    }
                }
            }
        };

        // --- 5. Lesson Observation Analysis Logic ---
        
        /**
         * Analyzes the structured observation data (either from LLM or CSV)
         * @param {Array<Object>} observationData - Array of observation objects.
         * @returns {Object}
         */
        const analyzeObservationData = (observationData) => {
            let combinedData = observationData;
            if (combinedData.length === 0) return { overallMetrics: [], subjectAverages: {} };

            // Ensure numeric scores and clean subjects
            const OBS_SCORE_COLS = ['Pace', 'Engagement', 'Management'];
            
            combinedData.forEach(row => {
                row.Subject = row.Subject || 'Unspecified';
                row.Source_Term = row.Source_Term || 'Unspecified Observation';
                OBS_SCORE_COLS.forEach(col => {
                    row[col] = parseFloat(row[col]) || 0; // Convert scores to numbers
                });
            });

            // Calculate Overall Score
            combinedData.forEach(row => {
                const scores = OBS_SCORE_COLS.map(col => row[col]).filter(s => s > 0);
                row['Obs_Overall_Score'] = scores.length ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
            });

            // Overall Term Averages 
            const termAverages = {};
            combinedData.forEach(row => {
                const term = row['Source_Term'];
                termAverages[term] = termAverages[term] || { count: 0, totalScores: {} };
                termAverages[term].count++;
                OBS_SCORE_COLS.concat(['Obs_Overall_Score']).forEach(col => {
                    termAverages[term].totalScores[col] = (termAverages[term].totalScores[col] || 0) + row[col];
                });
            });

            const overallMetrics = [];
            Object.keys(termAverages).sort().forEach(term => {
                const avgRow = { Source_Term: term };
                OBS_SCORE_COLS.concat(['Obs_Overall_Score']).forEach(col => {
                    avgRow[col] = termAverages[term].totalScores[col] / termAverages[term].count;
                });
                overallMetrics.push(avgRow);
            });


            // Subject Averages
            const subjectAverages = {};
            combinedData.forEach(row => {
                const subject = row['Subject'];
                const avgScores = {};
                OBS_SCORE_COLS.forEach(col => {
                    avgScores[col] = row[col];
                });
                
                const lowestScoreCol = OBS_SCORE_COLS.reduce((minCol, col) => 
                    avgScores[col] < avgScores[minCol] ? col : minCol, OBS_SCORE_COLS[0]
                );
                
                // For observation, we typically only report the latest single result
                subjectAverages[subject] = {
                    latest_term: row['Source_Term'],
                    latest_score: row['Obs_Overall_Score'],
                    lowest_area: lowestScoreCol.toUpperCase()
                };
            });
            
            return { overallMetrics, subjectAverages };
        };


        // --- 6. Rendering Functions ---
        
        let analysisResults = { studentFeedbackData: null, observationData: null };

        const renderOverallScores = (metrics) => {
            const container = document.getElementById('overall-scores');
            if (!metrics || metrics.length === 0) {
                container.innerHTML = `<p class="chalk-text text-lg p-4 text-gray-400">No student feedback data available for term comparison.</p>`;
                return;
            }

            const t1Label = metrics[0].t1_label; 
            const t3Label = metrics[0].t3_label; 
            
            let tableHTML = `
                <table class="w-full text-left border-collapse">
                    <thead>
                        <tr class="chalk-text text-lg border-b border-gray-500">
                            <th class="p-3 font-bold">Metric (Score 1-5)</th>
                            <th class="p-3 font-bold text-center">${t1Label.split(' ')[0]} (Avg)</th>
                            <th class="p-3 font-bold text-center">${t3Label.split(' ')[0]} (Avg)</th>
                            <th class="p-3 font-bold text-center">Change</th>
                            <th class="p-3 font-bold">Trend</th>
                        </tr>
                    </thead>
                    <tbody class="chalk-text text-base">
            `;

            metrics.forEach(item => {
                const change = (item.t3 - item.t1).toFixed(2);
                const trendIcon = change > 0 ? '‚ñ≤' : (change < 0 ? '‚ñº' : '‚ñ¨');
                const trendColor = change > 0 ? 'text-green-400' : (change < 0 ? 'text-red-400' : 'text-gray-400');
                const backgroundColor = item.t3 > item.t1 ? 'bg-green-800/20' : (item.t3 < item.t1 ? 'bg-red-800/20' : '');


                tableHTML += `
                    <tr class="border-b border-gray-600 hover:${backgroundColor}">
                        <td class="p-3 font-semibold ${item.color}">${item.metric}</td>
                        <td class="p-3 text-center">${item.t1.toFixed(2)}</td>
                        <td class="p-3 text-center font-bold ${item.t3 > item.t1 ? 'text-yellow-300' : ''}">${item.t3.toFixed(2)}</td>
                        <td class="p-3 text-center ${trendColor}">${change}</td>
                        <td class="p-3 text-center ${trendColor} text-xl">${trendIcon}</td>
                    </tr>
                `;
            });

            tableHTML += `</tbody></table>`;
            container.innerHTML = tableHTML;
        };

        const renderSubjectTrends = (studentAverages, obsAverages) => {
            const container = document.getElementById('subject-trends');
            container.innerHTML = ''; 

            const allSubjects = new Set([...Object.keys(studentAverages), ...Object.keys(obsAverages)]);
            if (allSubjects.size === 0) {
                 container.innerHTML = `<p class="chalk-text p-4 md:col-span-3 text-center text-gray-400">No subject-specific data available yet.</p>`;
                 return;
            }

            allSubjects.forEach(subject => {
                const studentData = studentAverages[subject];
                const obsData = obsAverages[subject];

                // Student Metrics
                const latestScore = studentData ? studentData.latest_score.toFixed(2) : 'N/A';
                const lowestStudentArea = studentData ? studentData.lowest_area : 'N/A (No Feedback)';
                const studentTerm = studentData ? studentData.latest_term.split(' ')[0] : 'N/A';
                
                // Get history for trend calculation
                let changeIndicator = '';
                if (studentData && studentData.full_history.length > 1) {
                    const history = studentData.full_history;
                    const latestTermScore = history[history.length - 1].Overall_Avg_Score;
                    const earliestTermScore = history[0].Overall_Avg_Score;
                    
                    const change = (latestTermScore - earliestTermScore).toFixed(2);
                    const trend = change > 0 ? `<span class="text-green-400">‚ñ≤ +${change}</span>` : `<span class="text-red-400">‚ñº ${change}</span>`;
                    const earliestLabel = history[0].Source_Term.split(' ')[0];
                    const latestLabel = history[history.length - 1].Source_Term.split(' ')[0];
                    changeIndicator = `<p class="text-sm chalk-text mt-1">${earliestLabel} vs ${latestLabel}: ${trend}</p>`;
                }
                
                // Observation Metrics
                const obsScore = obsData ? obsData.latest_score.toFixed(2) : 'N/A';
                const obsLowestArea = obsData ? obsData.lowest_area : 'N/A (No Observation)';
                const obsTerm = obsData ? obsData.latest_term.split(' ')[0] : 'N/A';

                // Card Structure
                const cardHTML = `
                    <div class="score-box p-6 rounded-xl hover:ring-4 hover:ring-yellow-500/50 transition duration-300">
                        <h3 class="text-2xl font-bold chalk-text mb-3 text-blue-300">${subject}</h3>
                        
                        <div class="flex justify-between items-end mb-4 border-b border-gray-600 pb-2">
                             <div>
                                <p class="text-sm chalk-text">Student Avg. (${studentTerm})</p>
                                <p class="text-4xl font-extrabold ${latestScore >= 4.3 ? 'text-yellow-300' : 'text-orange-300'}">${latestScore}</p>
                                ${changeIndicator}
                            </div>
                            <div>
                                <p class="text-sm chalk-text text-right">Obs. Score (${obsTerm})</p>
                                <p class="text-4xl font-extrabold text-pink-300 text-right">${obsScore}</p>
                            </div>
                        </div>
                        
                        <div class="mt-2">
                            <p class="text-sm font-light chalk-text mb-1 text-yellow-500">Key Focus Areas:</p>
                            <p class="text-base font-semibold text-red-300">Student Feedback: ${lowestStudentArea}</p>
                            <p class="text-base font-semibold text-red-300">Observation: ${obsLowestArea}</p>
                        </div>
                    </div>
                `;
                container.innerHTML += cardHTML;
            });
        };

        const renderQualitativeFeedback = (qualitative) => {
            const renderList = (id, items) => {
                const container = document.getElementById(id);
                if (items && items.length > 0) {
                     container.innerHTML = items.map(item => `<li class="text-lg">${item}</li>`).join('');
                } else {
                     container.innerHTML = `<li class="text-lg text-gray-400">No qualitative data found in files.</li>`;
                }
            };
            
            if (qualitative) {
                renderList('positive-feedback-list', qualitative.positive);
                renderList('improvement-feedback-list', qualitative.improvement);
            }
        };
        
        const renderObservationMetrics = (obsMetrics) => {
             const container = document.getElementById('observation-metrics');

             if (!obsMetrics || obsMetrics.length === 0) {
                 container.innerHTML = `<p class="chalk-text text-lg text-gray-400">No professional observation data has been analyzed.</p>`;
                 return;
             }
             
             // Get the latest observation data
             const latestObs = obsMetrics[obsMetrics.length - 1];
             const latestTerm = latestObs.Source_Term;
             const overallScore = latestObs.Obs_Overall_Score.toFixed(2);
             
             const metricsToDisplay = [
                 { label: 'Lesson Pace', key: 'Pace' },
                 { label: 'Student Engagement', key: 'Engagement' },
                 { label: 'Classroom Management', key: 'Management' }
             ];

             let html = `
                <p class="text-lg font-semibold chalk-text mb-3">Latest Report: <span class="text-yellow-300">${latestTerm}</span></p>
                <div class="mb-4 p-4 rounded-lg bg-gray-700/30">
                    <p class="text-xl chalk-text font-light">Overall Observation Score (Avg of Metrics)</p>
                    <p class="text-5xl font-extrabold text-pink-400">${overallScore}</p>
                </div>
             `;
             
             html += `<ul class="space-y-3 pt-3">`;

             metricsToDisplay.forEach(m => {
                 const score = latestObs[m.key] ? latestObs[m.key].toFixed(2) : 'N/A';
                 html += `
                    <li class="flex justify-between items-center text-lg chalk-text border-b border-gray-600 pb-2">
                        <span>${m.label}:</span>
                        <span class="font-bold text-xl text-blue-300">${score}</span>
                    </li>
                 `;
             });
             
             html += `</ul>`;
             
             container.innerHTML = html;
        };


        // --- 7. Main Controller & DND Logic ---
        
        const analyzeButton = document.getElementById('analyze-button');
        const feedbackFilesInput = document.getElementById('feedback-files');
        const observationTextInput = document.getElementById('observation-text');
        const loadingSpinner = document.getElementById('loading-spinner');
        const analyzeIcon = document.getElementById('analyze-icon');
        const analyzeText = document.getElementById('analyze-text');
        const statusMessage = document.getElementById('analysis-status');
        
        const dropZone = document.getElementById('drop-zone');
        const fileCountElement = document.getElementById('file-count');
        const dropZoneText = document.getElementById('drop-text');

        // DND Handlers
        const handleDragOver = (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
            dropZoneText.textContent = 'Drop your CSV files now...';
        };

        const handleDragLeave = (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            updateDropZoneDisplay(feedbackFilesInput.files.length);
        };

        const handleDrop = (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            
            // Filter for CSVs only and assign to the input element
            const csvFiles = Array.from(files).filter(file => file.type === 'text/csv' || file.name.endsWith('.csv'));
            
            if (csvFiles.length > 0) {
                // Use DataTransfer object to create a FileList
                const dataTransfer = new DataTransfer();
                csvFiles.forEach(file => dataTransfer.items.add(file));
                feedbackFilesInput.files = dataTransfer.files;
                
                updateDropZoneDisplay(csvFiles.length);
            } else {
                updateDropZoneDisplay(feedbackFilesInput.files.length, 'Only CSV files accepted. Try again.');
            }
        };
        
        const updateDropZoneDisplay = (count, defaultText = 'Drag & drop your **CSV files** here, or click to browse.') => {
            dropZoneText.innerHTML = defaultText;
            if (count > 0) {
                fileCountElement.textContent = `${count} file${count === 1 ? '' : 's'} loaded. Click "Analyze" to proceed.`;
                fileCountElement.classList.remove('hidden');
            } else {
                fileCountElement.classList.add('hidden');
            }
        };

        const updateUIState = (isProcessing, message = '', isError = false) => {
            analyzeButton.disabled = isProcessing;
            loadingSpinner.style.display = isProcessing ? 'block' : 'none';
            analyzeIcon.style.display = isProcessing ? 'none' : 'block';
            analyzeText.textContent = isProcessing ? 'Analyzing Data...' : 'Analyze Data & Update Dashboard';
            statusMessage.textContent = message;
            statusMessage.classList.toggle('hidden', message === '');
            statusMessage.classList.remove('text-green-300', 'text-red-300');
            if (isError) {
                statusMessage.classList.add('text-red-300');
            } else if (message.includes('successfully')) {
                statusMessage.classList.add('text-green-300');
            } else if (message) {
                statusMessage.classList.add('text-yellow-300');
            }
        };

        const startAnalysis = async () => {
            updateUIState(true);
            
            const feedbackFiles = Array.from(feedbackFilesInput.files);
            const observationText = observationTextInput.value.trim();

            if (feedbackFiles.length === 0 && observationText.length === 0) {
                updateUIState(false, 'Please provide data (CSV or Observation Text) to analyze.', true);
                return;
            }

            try {
                // 1. Process Student Feedback Files
                const feedbackDataPromises = feedbackFiles.map(processFile);
                const feedbackDataFrames = await Promise.all(feedbackDataPromises);
                const studentFeedbackResults = analyzeStudentFeedback(feedbackDataFrames);
                
                // 2. Process Observation Data (Using LLM if text is present)
                let structuredObservationData = [];
                if (observationText) {
                    updateUIState(true, '1/2. Extracting Observation Data using LLM...');
                    structuredObservationData = await extractObservationDataWithGemini(observationText);
                    updateUIState(true, '2/2. Analyzing Extracted Data...');
                }
                
                const observationResults = analyzeObservationData(structuredObservationData);

                // 3. Update Global Results and Render
                analysisResults.studentFeedbackData = studentFeedbackResults;
                analysisResults.observationData = observationResults;

                renderOverallScores(studentFeedbackResults.overallMetrics);
                renderSubjectTrends(studentFeedbackResults.subjectAverages, observationResults.subjectAverages);
                renderQualitativeFeedback(studentFeedbackResults.qualitative);
                renderObservationMetrics(observationResults.overallMetrics);

                updateUIState(false, 'Analysis completed successfully! Dashboard updated.');

            } catch (error) {
                console.error("Analysis Error:", error);
                // Check if the error is due to an empty response from the LLM
                let userMessage = error.message || error;
                if (userMessage.includes("LLM returned an invalid candidate structure")) {
                    userMessage = "LLM Extraction Failed: The observation text was too ambiguous or empty. Please ensure the text contains subject, term, and clear feedback on Pace, Engagement, and Management (1-5 scores or descriptive text).";
                }
                updateUIState(false, `Analysis failed: ${userMessage}.`, true);
            }
        };

        window.onload = () => {
            analyzeButton.addEventListener('click', startAnalysis);
            updateUIState(false, 'Ready to analyze data.');
            
            // DND Wiring
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('dragleave', handleDragLeave);
            dropZone.addEventListener('drop', handleDrop);
            
            // Click to browse wiring
            dropZone.addEventListener('click', () => {
                feedbackFilesInput.click();
            });
            
            // Update display when using the click-to-browse method
            feedbackFilesInput.addEventListener('change', () => {
                updateDropZoneDisplay(feedbackFilesInput.files.length);
            });
        };

    </script>
</body>
</html>
